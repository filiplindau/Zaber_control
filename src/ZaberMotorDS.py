'''
Created on 16 Dec 2015

@author: Filip Lindau
'''

#     "$Name:  $";
#     "$Header:  $";
#=============================================================================
#
# file :        ZaberMotorDS.py
#
# description : Python source for the ZaberMotorDS and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                ZaberMotorDS are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author:  $
#
# $Revision:  $
#
# $Log:  $
#
# copyleft :    European Synchrotron Radiation Facility
#               BP 220, Grenoble 38043
#               FRANCE
#
#=============================================================================
#          This file is generated by POGO
#     (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================
#


import PyTango
import sys
import zaber_control as zc
import threading
import Queue
import time
import numpy as np

class ZaberCommand:
    def __init__(self, command, data=None):
        self.command = command
        self.data = data

class MotorData():
    def __init__(self):
            self.position = [None]
            self.speed = [None]
            self.acceleration = [None]
            self.runningCurrent = [None]
            self.holdCurrent = [None]
            self.microstepResolution = [None]
            self.deviceId = [None]    
            self.firmwareVersion = [None]
            self.serial = [None]
            self.status = [None,None]
            self.stepPerUnit = [1.0]

#==================================================================
#   ZaberMotorDS Class Description:
#
#         Controls a Zaber T series motor.
#
#==================================================================
#     Device States Description:
#
#   DevState.ON :       Connected to motor controller
#   DevState.MOVING :   Motor is moving
#   DevState.FAULT :    An error was detected. Probably communication.
#   DevState.ALARM :    The device is in an ALARM state due to an attribute being out of limits.
#   DevState.UNKNOWN :  Disconnected from motor controller
#==================================================================


class ZaberMotorDS(PyTango.Device_4Impl):

#--------- Add you global variables here --------------------------

#------------------------------------------------------------------
#     Device constructor
#------------------------------------------------------------------
    def __init__(self, cl, name):
        PyTango.Device_4Impl.__init__(self, cl, name)
        ZaberMotorDS.init_device(self)

#------------------------------------------------------------------
#     Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        with self.streamLock:
            self.info_stream(''.join(("[Device delete_device method] for device", self.get_name())))
        self.stopThread()


#------------------------------------------------------------------
#     Device initialization
#------------------------------------------------------------------
    def init_device(self):

        # Try stopping the stateThread if it was started before. Will fail if this
        # is the initial start.
        try:
            self.stopThread()
        except Exception, e:
            pass

        self.streamLock = threading.Lock()
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::init_device()")))
        self.set_state(PyTango.DevState.UNKNOWN)
        self.get_device_properties(self.get_device_class())

        
        self.attrLock = threading.Lock()
        self.stateThread = threading.Thread()
        threading.Thread.__init__(self.stateThread, target=self.stateHandlerDispatcher)

        self.commandQueue = Queue.Queue(100)
        self.motorData = MotorData()

        self.stateHandlerDict = {PyTango.DevState.ON: self.onHandler,
                                PyTango.DevState.MOVING: self.onHandler,
                                PyTango.DevState.ALARM: self.onHandler,
                                PyTango.DevState.STANDBY: self.onHandler,
                                PyTango.DevState.DISABLE: self.onHandler,
                                PyTango.DevState.FAULT: self.faultHandler,
                                PyTango.DevState.INIT: self.initHandler,
                                PyTango.DevState.UNKNOWN: self.unknownHandler,
                                PyTango.DevState.OFF: self.onHandler}

        self.stopStateThreadFlag = False

        self.stateThread.start()

    
    def stateHandlerDispatcher(self):
        """Handles switch of states in the state machine thread.
        Each state handled method should exit by setting the next state,
        going back to this method. The previous state is also included when
        calling the next state handler method.
        The thread is stopped by setting the stopStateThreadFlag.
        """
        prevState = self.get_state()
        while self.stopStateThreadFlag == False:
            try:
                self.stateHandlerDict[self.get_state()](prevState)
                prevState = self.get_state()
            except KeyError:
                self.stateHandlerDict[PyTango.DevState.UNKNOWN](prevState)
                prevState = self.get_state()

    def stopThread(self):
        """Stops the state handler thread by setting the stopStateThreadFlag
        """
        self.stopStateThreadFlag = True
        self.stateThread.join(3)
        try:
            self.device.close()
        except Exception:
            pass


    def unknownHandler(self, prevState):
        """Handles the UNKNOWN state, before communication with the hardware devices
        has been established. 
        """
        with self.streamLock:
            self.info_stream('Entering unknownHandler')
        connectionTimeout = 1.0
        self.set_status('Connecting to motor controller')

        while self.stopStateThreadFlag == False:
            try:
                self.device.close()
            except Exception:
                pass
            try:
                self.device = zc.ZaberControl(self.Port)
                self.device.connect(self.Port)
            except Exception, e:
                self.error_stream(''.join(('Error creating ZaberControl object: ', str(e))))
                self.device = None
                time.sleep(connectionTimeout)
                continue

            self.set_state(PyTango.DevState.INIT)
            break

    def initHandler(self, prevState):
        """Handles the INIT state. Query zaber device to see if it is alive. 
        Set initial parameters
        """
        with self.streamLock:
            self.info_stream('Entering initHandler')
        waitTime = 1.0
        self.set_status('Initializing device')
        retries = 0
        maxTries = 5

        while self.stopStateThreadFlag == False:
            retries += 1
            if retries > maxTries:
                self.set_state(PyTango.DevState.UNKNOWN)
                break
            try:
                with self.streamLock:
                    self.info_stream('Trying to connect...')     
                # Initial read of all parameters               
                self.motorData.deviceId = [self.device.getDeviceId(self.Motor)]
                self.motorData.firmwareVersion = [self.device.getFirmwareVersion(self.Motor)/100.0]
                self.motorData.microstepResolution = [self.device.getMicrostepResolution(self.Motor)]
                self.motorData.position = [self.device.getPosition(self.Motor)/self.motorData.microstepResolution[0]]
                self.motorData.speed = [self.device.getTargetSpeed(self.Motor)/self.motorData.microstepResolution[0]]
                self.motorData.acceleration = [self.device.getAcceleration(self.Motor)/self.motorData.microstepResolution[0]]
                self.motorData.holdCurrent = [self.device.getHoldCurrent(self.Motor)*100]
                self.motorData.runningCurrent = [self.device.getRunningCurrent(self.Motor)*100]
                self.motorData.status = [self.device.getStatus(self.Motor)]
                
                attrs = self.get_device_attr()
                cal = attrs.get_w_attr_by_name('Step_per_unit').get_write_value()
                self.motorData.stepPerUnit = [cal]
                
                with self.streamLock:
                    self.info_stream(''.join(('Position: ', str(self.motorData.position))))
                    self.info_stream(''.join(('Firmware: ', str(self.motorData.firmwareVersion))))
                    self.info_stream(''.join(('Device id: ', str(self.motorData.deviceId))))
                    self.info_stream(''.join(('Running current: ', str(self.motorData.runningCurrent))))
                    self.info_stream(''.join(('Hold current: ', str(self.motorData.holdCurrent))))

            except Exception, e:
                with self.streamLock:
                    self.error_stream(''.join(('Error when initializing device')))
                    self.error_stream(str(e))
                self.checkCommands(blockTime=waitTime)
                continue

            self.set_state(PyTango.DevState.ON)
            break

    def onHandler(self, prevState):
        """Handles the ON state. Connected to the Zaber controller COM port.
        Waits in a loop checking commands.
        """
        with self.streamLock:
            self.info_stream('Entering onHandler')
        handledStates = [PyTango.DevState.ON, PyTango.DevState.ALARM, PyTango.DevState.MOVING, PyTango.DevState.DISABLE, PyTango.DevState.STANDBY, PyTango.DevState.OFF]
        
        # We will cycle through these commands, populating the motorData structure.
        # The device is rather slow, so only one command at a time before checking 
        # if something has happened
        commandList = ['readPosition', 'readStatus']        
        nextCommand = 0
        waitTime = 0.2
        self.set_status('On')

        while self.stopStateThreadFlag == False:
#            self.info_stream('onhandler loop')
            with self.attrLock:
                state = self.get_state()
            if state not in handledStates:
                break
            # Read laser parameters
            with self.attrLock:
                if self.commandQueue.empty() == True:
                    try:
                        cmdMsg = ZaberCommand(commandList[nextCommand])
                        self.info_stream(''.join(('Issuing command ', commandList[nextCommand])))
                        nextCommand = (nextCommand + 1) % commandList.__len__()
                        self.commandQueue.put(cmdMsg)
                    except Exception, e:
                        with self.streamLock:
                            self.error_stream(''.join(('Error reading zaber: ', str(e))))
                            self.set_state(PyTango.DevState.FAULT)
                            print e
                            break                
                        
            self.checkCommands(blockTime=waitTime)
            self.adjust_State()
            
            
    def faultHandler(self, prevState):
        """Handles the FAULT state. A problem has been detected.
        """
        with self.streamLock:
            self.info_stream('Entering faultHandler from')
            self.info_stream(str(prevState))
        handledStates = [PyTango.DevState.FAULT]
        waitTime = 0.1
        retries = 0
        maxTries = 5

        faultProcessFlag = True
        s = ''.join(('Fault condition. Processing...\n'))
        t0 = time.time()
        
        while self.stopStateThreadFlag == False:
            if self.get_state() not in handledStates:
                break
            try:
                with self.streamLock:
                    self.info_stream('Closing device...')
                self.device.close()
                faultProcessFlag = False
            except Exception, e:
                with self.streamLock:
                    self.error_stream(''.join(('Close...', str(e))))
                self.set_state(PyTango.DevState.FAULT)
                self.set_status(''.join((s, 'Error closing connection')))
                faultProcessFlag = True
            if faultProcessFlag == False:
                try:
                    with self.streamLock:
                        self.info_stream('Connecting to device...')
                    self.device.connect(self.Port)
                    faultProcessFlag = False
                except Exception, e:
                    with self.streamLock:
                        self.error_stream(''.join(('Connect...', str(e))))
                    self.set_state(PyTango.DevState.UNKNOWN)
                    self.set_status(''.join((s, 'Error connecting')))
                    faultProcessFlag = True
            if faultProcessFlag == False:
                try:
                    with self.streamLock:
                        self.info_stream('Getting device status...')
                    stat = self.device.getStatus()
                    with self.streamLock:
                        self.info_stream(stat[1]) 
                    self.motorData.status = [stat]                   
                    faultProcessFlag = False
                except Exception, e:
                    with self.streamLock:
                        self.error_stream(''.join(( 'Communicate...', str(e))))
                    self.set_state(PyTango.DevState.FAULT)
                    self.set_status(''.join((s, 'Error receiving response')))
                    faultProcessFlag = True
            if time.time() - t0 > 10:
                retries = maxTries + 1
            retries += 1
            if faultProcessFlag == False:
                with self.streamLock:
                    self.info_stream('Fault condition cleared, going back')
                self.set_state(PyTango.DevState.ON)
            elif retries > maxTries:
                with self.streamLock:
                    self.info_stream('Cannot clear fault, going to UNKNOWN state')
                self.set_state(PyTango.DevState.UNKNOWN)
            

    def checkCommands(self, blockTime=0):
        """Checks the commandQueue for new commands. Must be called regularly.
        If the queue is empty the method exits immediately.
        """
#         with self.streamLock:
#             self.debug_stream('Entering checkCommands')
        try:
            if blockTime == 0:
#                 with self.streamLock:
#                     self.debug_stream('checkCommands: blockTime == 0')
                cmd = self.commandQueue.get(block=False)
            else:
#                 with self.streamLock:
#                     self.debug_stream('checkCommands: blockTime != 0')
                cmd = self.commandQueue.get(block=True, timeout=blockTime)
#             with self.streamLock:
#                 self.info_stream(str(cmd.command))
            if cmd.command == 'writePosition':
                with self.streamLock:
                    self.info_stream(''.join(('Write position ', str(cmd.data))))
                with self.attrLock:
                    data = np.int(np.double(cmd.data*self.motorData.stepPerUnit[0])*self.motorData.microstepResolution[0])                    
                    self.device.setPositionAbsolute(data, self.Motor)
                self.info_stream(''.join(('Setting position ', str(data))))
            elif cmd.command == 'readPosition':
                with self.streamLock:
                    self.info_stream(''.join(('Read position ')))
                with self.attrLock:
                    data = self.device.getPosition(self.Motor)
                    self.motorData.position = [np.double(data)/self.motorData.stepPerUnit[0]/self.motorData.microstepResolution[0]]
            elif cmd.command == 'writeStepPerUnit':
                with self.streamLock:
                    self.info_stream(''.join(('Write steps per unit')))
                with self.attrLock:
                    self.motorData.stepPerUnit = [cmd.data]
                    
            elif cmd.command == 'writeSpeed':
                with self.streamLock:
                    self.info_stream(''.join(('Write speed ')))
                with self.attrLock:
                    data = self.device.setTargetSpeed(cmd.data*self.motorData.microstepResolution[0], self.Motor)
                    self.motorData.speed = [np.double(data)/self.motorData.microstepResolution[0]]
            elif cmd.command == 'readSpeed':
                with self.streamLock:
                    self.info_stream(''.join(('Read speed ')))
                with self.attrLock:
                    data = self.device.getTargetSpeed(self.Motor)
                    self.motorData.speed = [np.double(data)/self.motorData.microstepResolution[0]]

            elif cmd.command == 'writeAcceleration':
                with self.streamLock:
                    self.info_stream(''.join(('Write acceleration ')))
                with self.attrLock:
                    data = self.device.setAcceleration(cmd.data*self.motorData.microstepResolution[0], self.Motor)
                    self.motorData.acceleration = [np.double(data)/self.motorData.microstepResolution[0]]
            elif cmd.command == 'readAcceleration':
                with self.streamLock:
                    self.info_stream(''.join(('Read acceleration ')))
                with self.attrLock:
                    data = self.device.getAcceleration(self.Motor)
                    self.motorData.acceleration = [np.double(data)/self.motorData.microstepResolution[0]]

            elif cmd.command == 'writeMicrostepResolution':
                with self.streamLock:
                    self.info_stream(''.join(('Write microstep resolution ')))
                with self.attrLock:
                    data = self.device.setMicrostepResolution(cmd.data, self.Motor)
                    self.motorData.microstepResolution = [data]
            elif cmd.command == 'readMicrostepResolution':
                with self.streamLock:
                    self.info_stream(''.join(('Read microstep resolution ')))
                with self.attrLock:
                    data = self.device.getMicrostepResolution(self.Motor)
                    self.motorData.microstepResolution = [data]
                
            elif cmd.command == 'writeRunningCurrent':
                with self.streamLock:
                    self.info_stream(''.join(('Write running current ')))
                with self.attrLock:
                    print "write running current", cmd.data
                    data = self.device.setRunningCurrent(cmd.data/100.0, self.Motor)
                    print "read running current", data
                    self.motorData.runningCurrent = [data*100]
                    cmdRead = ZaberCommand('readRunningCurrent')
                    self.commandQueue.put(cmdRead)
            elif cmd.command == 'readRunningCurrent':
                with self.streamLock:
                    self.info_stream(''.join(('Read running current ')))
                with self.attrLock:
                    data = self.device.getRunningCurrent(self.Motor)                    
                    self.motorData.runningCurrent = [data*100]

            elif cmd.command == 'writeHoldCurrent':
                with self.streamLock:
                    self.info_stream(''.join(('Write hold current ')))
                with self.attrLock:
                    data = self.device.setHoldCurrent(cmd.data/100.0, self.Motor)
                    self.motorData.holdCurrent = [data*100]
            elif cmd.command == 'readHoldCurrent':
                with self.streamLock:
                    self.info_stream(''.join(('Read hold current ')))
                with self.attrLock:
                    data = self.device.getHoldCurrent(self.Motor)
                    self.motorData.holdCurrent = [data*100]


            elif cmd.command == 'readStatus':
                with self.streamLock:
                    self.info_stream(''.join(('Read Status')))
                with self.attrLock:
                    data = self.device.getStatus(self.Motor)
                    self.motorData.status = [data]
                    

            elif cmd.command == 'stop' or cmd.command == 'standby':
                if self.get_state() not in [PyTango.DevState.INIT, PyTango.DevState.UNKNOWN]:
                    with self.attrLock:
                        self.device.stop(self.Motor)

            elif cmd.command == 'home':
                if self.get_state() not in [PyTango.DevState.INIT, PyTango.DevState.UNKNOWN]:
                    with self.attrLock:
                        self.device.homeMotor(self.Motor)



            elif cmd.command == 'init':
                if self.get_state() not in [PyTango.DevState.UNKNOWN]:
                    self.set_state(PyTango.DevState.UNKNOWN)
                    
            elif cmd.command == 'on':
                if self.get_state() not in [PyTango.DevState.UNKNOWN]:
                    self.set_state(PyTango.DevState.ON)
                    
        except Queue.Empty:
            with self.streamLock:
                self.info_stream('checkCommands: queue empty')
                
        except Exception, e:
            with self.streamLock:
                self.error_stream(''.join(('Error in checkCommands: ', str(e))))
#                PyTango.Except.throw_exception('test', 'test', 'test')
#                ex_type, ex, tb = sys.exc_info()
#                PyTango.Except.throw_python_exception(ex_type, ex, tb)
#                PyTango.Except.throw_exception(s[0], s[1], origin, sever=PyTango.ErrSeverity.WARN)
                self.set_state(PyTango.DevState.FAULT)
                

    def adjust_State(self):
        '''
        Updates the state based on the information in the motorData variable.
        '''
        
#         if self.get_state() != PyTango.DevState.ALARM:
#             # Do not change state if we are in ALARM
        self.debug_stream(''.join(('Adjust state status data: ', str(self.motorData.status[0]))))
        if self.motorData.status[0][0] == 0:
            self.set_state(PyTango.DevState.ON)
            self.set_status('Idle')
        elif self.motorData.status[0][0] == 1:
            self.set_state(PyTango.DevState.MOVING)
            self.set_status('Homing')
        elif self.motorData.status[0][0] == 18:
            self.set_state(PyTango.DevState.MOVING)
            self.set_status('Move manual control')
        elif self.motorData.status[0][0] == 20:
            self.set_state(PyTango.DevState.MOVING)
            self.set_status('Moving to absolute position')
        elif self.motorData.status[0][0] == 21:
            self.set_state(PyTango.DevState.MOVING)
            self.set_status('Moving to relative position')
        elif self.motorData.status[0][0] == 22:
            self.set_state(PyTango.DevState.MOVING)
            self.set_status('Moving with constant speed')
        elif self.motorData.status[0][0] == 23:
            self.set_state(PyTango.DevState.MOVING)
            self.set_status('Stopping')
#         else:
#             self.set_state(PyTango.DevState.FAULT)
#             self.set_status('Status data not initialized')
                

                    
#------------------------------------------------------------------
#     Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        
#         print "In ", self.get_name(), "::always_excuted_hook()"
        pass



#------------------------------------------------------------------
#     Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self, data):
#         print "In ", self.get_name(), "::read_attr_hardware()"
        pass

#==================================================================
#
#     ZaberMotorDS read/write attribute methods
#
#==================================================================

#------------------------------------------------------------------
#     Read Position attribute
#------------------------------------------------------------------
    def read_Position(self, attr):
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::read_Position()")))
        with self.attrLock:
            attr_read = self.motorData.position[0]
            if attr_read == None:
                attr.set_quality(PyTango.AttrQuality.ATTR_INVALID)
                attr_read = 0.0
            attr.set_value(attr_read)


#------------------------------------------------------------------
#     Write Position attribute
#------------------------------------------------------------------
    def write_Position(self, attr):
        with self.streamLock:
            msg = ''.join(("In ", self.get_name(), "::write_Position()"))
            self.info_stream(msg)
        
        data = attr.get_write_value()
        
        with self.streamLock:
            msg = ''.join(( "Attribute value = ", str(data)))
            self.info_stream(msg)

        #     Add your own code here
        cmdMsg = ZaberCommand('writePosition', data)
        self.commandQueue.put(cmdMsg)


#---- Position attribute State Machine -----------------
    def is_Position_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.UNKNOWN]:
            #     End of Generated Code
            #     Re-Start of Generated Code
            return False
        return True

#------------------------------------------------------------------
#     Read Step_per_unit attribute
#------------------------------------------------------------------
    def read_Step_per_unit(self, attr):
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::read_Step_per_unit()")))
        with self.attrLock:
            attr_read = self.motorData.stepPerUnit[0]
            if attr_read == None:
                attr.set_quality(PyTango.AttrQuality.ATTR_INVALID)
                attr_read = 0.0
            attr.set_value(attr_read)


#------------------------------------------------------------------
#     Write Step_per_unit attribute
#------------------------------------------------------------------
    def write_Step_per_unit(self, attr):
        with self.streamLock:
            msg = ''.join(("In ", self.get_name(), "::write_Step_per_unit()"))
            self.info_stream(msg)
        
        data = attr.get_write_value()
        
        with self.streamLock:
            msg = ''.join(( "Attribute value = ", str(data)))
            self.info_stream(msg)

        #     Add your own code here
        cmdMsg = ZaberCommand('writeStepPerUnit', data)
        self.commandQueue.put(cmdMsg)


#---- Step_per_unit attribute State Machine -----------------
    def is_Step_per_unit_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.UNKNOWN]:
            #     End of Generated Code
            #     Re-Start of Generated Code
            return False
        return True

#------------------------------------------------------------------
#     Read Speed attribute
#------------------------------------------------------------------
    def read_Speed(self, attr):
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::read_Speed()")))
        with self.attrLock:
            attr_read = self.motorData.speed[0]
            if attr_read == None:
                attr.set_quality(PyTango.AttrQuality.ATTR_INVALID)
                attr_read = 0.0
            attr.set_value(attr_read)


#------------------------------------------------------------------
#     Write Speed attribute
#------------------------------------------------------------------
    def write_Speed(self, attr):
        with self.streamLock:
            msg = ''.join(("In ", self.get_name(), "::write_Speed()"))
            self.info_stream(msg)
        
        data = attr.get_write_value()
        
        with self.streamLock:
            msg = ''.join(( "Attribute value = ", str(data)))
            self.info_stream(msg)

        #     Add your own code here
        cmdMsg = ZaberCommand('writeSpeed', data)
        self.commandQueue.put(cmdMsg)


#---- Speed attribute State Machine -----------------
    def is_Speed_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.UNKNOWN]:
            #     End of Generated Code
            #     Re-Start of Generated Code
            return False
        return True



#------------------------------------------------------------------
#     Read Acceleration attribute
#------------------------------------------------------------------
    def read_Acceleration(self, attr):
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::read_Acceleration()")))
        with self.attrLock:
            attr_read = self.motorData.acceleration[0]
            if attr_read == None:
                attr.set_quality(PyTango.AttrQuality.ATTR_INVALID)
                attr_read = 0.0
            attr.set_value(attr_read)


#------------------------------------------------------------------
#     Write Acceleration attribute
#------------------------------------------------------------------
    def write_Acceleration(self, attr):
        with self.streamLock:
            msg = ''.join(("In ", self.get_name(), "::write_Acceleration()"))
            self.info_stream(msg)
        
        data = attr.get_write_value()
        
        with self.streamLock:
            msg = ''.join(( "Attribute value = ", str(data)))
            self.info_stream(msg)

        #     Add your own code here
        cmdMsg = ZaberCommand('writeAcceleration', data)
        self.commandQueue.put(cmdMsg)


#---- Acceleration attribute State Machine -----------------
    def is_Acceleration_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.UNKNOWN]:
            #     End of Generated Code
            #     Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#     Read RunningCurrent attribute
#------------------------------------------------------------------
    def read_RunningCurrent(self, attr):
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::read_RunningCurrent()")))
            self.info_stream(str(self.motorData.runningCurrent[0]))
        with self.attrLock:
            attr_read = self.motorData.runningCurrent[0]
            if attr_read == None:
                attr.set_quality(PyTango.AttrQuality.ATTR_INVALID)
                attr_read = 0.0
            attr.set_value(attr_read)


#------------------------------------------------------------------
#     Write RunningCurrent attribute
#------------------------------------------------------------------
    def write_RunningCurrent(self, attr):
        with self.streamLock:
            msg = ''.join(("In ", self.get_name(), "::write_RunningCurrent()"))
            self.info_stream(msg)
        
        data = attr.get_write_value()
        
        with self.streamLock:
            msg = ''.join(( "Attribute value = ", str(data)))
            self.info_stream(msg)

        #     Add your own code here
        cmdMsg = ZaberCommand('writeRunningCurrent', data)
        self.commandQueue.put(cmdMsg)


#---- RunningCurrent attribute State Machine -----------------
    def is_RunningCurrent_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.UNKNOWN]:
            #     End of Generated Code
            #     Re-Start of Generated Code
            return False
        return True



#------------------------------------------------------------------
#     Read HoldCurrent attribute
#------------------------------------------------------------------
    def read_HoldCurrent(self, attr):
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::read_HoldCurrent()")))
        with self.attrLock:
            attr_read = self.motorData.holdCurrent[0]
            if attr_read == None:
                attr.set_quality(PyTango.AttrQuality.ATTR_INVALID)
                attr_read = 0.0
            attr.set_value(attr_read)


#------------------------------------------------------------------
#     Write HoldCurrent attribute
#------------------------------------------------------------------
    def write_HoldCurrent(self, attr):
        with self.streamLock:
            msg = ''.join(("In ", self.get_name(), "::write_HoldCurrent()"))
            self.info_stream(msg)
        
        data = attr.get_write_value()
        
        with self.streamLock:
            msg = ''.join(( "Attribute value = ", str(data)))
            self.info_stream(msg)

        #     Add your own code here
        cmdMsg = ZaberCommand('writeHoldCurrent', data)
        self.commandQueue.put(cmdMsg)


#---- HoldCurrent attribute State Machine -----------------
    def is_HoldCurrent_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.UNKNOWN]:
            #     End of Generated Code
            #     Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#     Read MicrostepResolution attribute
#------------------------------------------------------------------
    def read_MicrostepResolution(self, attr):
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::read_MicrostepResolution()")))
        with self.attrLock:
            attr_read = self.motorData.microstepResolution[0]
            if attr_read == None:
                attr.set_quality(PyTango.AttrQuality.ATTR_INVALID)
                attr_read = 0.0
            attr.set_value(attr_read)


#------------------------------------------------------------------
#     Write MicrostepResolution attribute
#------------------------------------------------------------------
    def write_MicrostepResolution(self, attr):
        with self.streamLock:
            msg = ''.join(("In ", self.get_name(), "::write_MicrostepResolution()"))
            self.info_stream(msg)
        
        data = attr.get_write_value()
        
        with self.streamLock:
            msg = ''.join(( "Attribute value = ", str(data)))
            self.info_stream(msg)

        #     Add your own code here
        cmdMsg = ZaberCommand('writeMicrostepResolution', data)
        self.commandQueue.put(cmdMsg)


#---- MicrostepResolution attribute State Machine -----------------
    def is_MicrostepResolution_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT,
                                PyTango.DevState.UNKNOWN]:
            #     End of Generated Code
            #     Re-Start of Generated Code
            return False
        return True





#------------------------------------------------------------------
#     Read FirmwareVersion attribute
#------------------------------------------------------------------
    def read_FirmwareVersion(self, attr):
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::read_FirmwareVersion()")))
        with self.attrLock:
            attr_read = self.motorData.firmwareVersion[0]
            if attr_read == None:
                attr.set_quality(PyTango.AttrQuality.ATTR_INVALID)
                attr_read = 'unknown'
                
            attr.set_value(attr_read)

#---- FirmwareVersion attribute State Machine -----------------
    def is_FirmwareVersion_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.UNKNOWN]:
            #     End of Generated Code
            #     Re-Start of Generated Code
            return False
        return True

#------------------------------------------------------------------
#     Read DeviceID attribute
#------------------------------------------------------------------
    def read_DeviceID(self, attr):
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::read_DeviceID()")))
        with self.attrLock:
            attr_read = self.motorData.deviceId[0]
            if attr_read == None:
                attr.set_quality(PyTango.AttrQuality.ATTR_INVALID)
                attr_read = 0.0
                
            attr.set_value(attr_read)

#---- DeviceID attribute State Machine -----------------
    def is_DeviceID_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.UNKNOWN]:
            #     End of Generated Code
            #     Re-Start of Generated Code
            return False
        return True

#==================================================================
#
#     ZaberMotorDS command methods
#
#==================================================================



#------------------------------------------------------------------
#     Home command:
#
#     Description: 
#------------------------------------------------------------------
    def Home(self):
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::Home()")))
        cmdMsg = ZaberCommand('home')
        self.commandQueue.put(cmdMsg)


#---- Home command State Machine -----------------
    def is_Home_allowed(self):
        if self.get_state() in [PyTango.DevState.UNKNOWN]:
            #     End of Generated Code
            #     Re-Start of Generated Code
            return False
        return True

#------------------------------------------------------------------
#     Stop command:
#
#     Description: 
#------------------------------------------------------------------
    def Stop(self):
        with self.streamLock:
            self.info_stream(''.join(("In ", self.get_name(), "::Stop()")))
        cmdMsg = ZaberCommand('stop')
        self.commandQueue.put(cmdMsg)


#---- Stop command State Machine -----------------
    def is_Stop_allowed(self):
        if self.get_state() in [PyTango.DevState.UNKNOWN]:
            #     End of Generated Code
            #     Re-Start of Generated Code
            return False
        return True


#==================================================================
#
#     ZaberMotorDSClass class definition
#
#==================================================================
class ZaberMotorDSClass(PyTango.DeviceClass):

    #     Class Properties
    class_property_list = {
        }


    #     Device Properties
    device_property_list = {
        'Port':
            [PyTango.DevString,
            "Serial port that the laser is connected to.",
            [ "COM0" ] ],
        'Motor':
            [PyTango.DevLong,
            "Motor number to control.",
            [ 0 ] ],
                            
        }


    #     Command definitions
    cmd_list = {
        'Home':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Stop':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        }


    #     Attribute definitions
    attr_list = {        
        'Position':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"position",
                'unit':"mm",
                'display unit':"mm",
                'description':"Motor position in mm.",
                'Memorized':"true_without_hard_applied",
                'Polling period':100,
            } ],
        'Step_per_unit':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"steps per unit",
                'unit':"",
                'display unit':"",
                'description':"Calibration of position in units of mm or deg.",
                'Memorized':"true_without_hard_applied",
                'Polling period':500,
            } ],
        'Speed':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"speed",
                'unit':"steps/s",
                'display unit':"steps/s",
                'description':"Motor speed in steps.",
                'Memorized':"true_without_hard_applied",
                'Polling period':500,
            } ],
        'Acceleration':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"acceleration",
                'unit':"steps/s^2",
                'display unit':"steps/s^2",
                'description':"Motor acceleration in steps/s^2.",
                'Memorized':"true_without_hard_applied",
                'Polling period':1000,
            } ],                 
        'MicrostepResolution':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"microstep resolution",
                'unit':"microsteps",
                'display unit':"microsteps",
                'description':"Motor microstep resolution. 1, 2, 4, 8, 16, 32, 64, 128",
                'Memorized':"true_without_hard_applied",
                'Polling period':1000,
            } ],
        'RunningCurrent':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"running current",
                'unit':"%",
                'display unit':"%",
                'max value':66,
                'min value':0,
                'Memorized':"true_without_hard_applied",
                'description': 'Running current during movement. Expressed as percentage of maximum current',
                'Polling period':1000,
            } ],
        'HoldCurrent':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"hold current",
                'unit':"%",
                'display unit':"%",
                'max value':66,
                'min value':0,
                'Memorized':"true_without_hard_applied",
                'description': 'Hold current when not moving. Expressed as percentage of maximum current',
                'Polling period':1000,
            } ],
        'DeviceID':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'description':"Device id number of the Zaber controller",
            } ],                 
        'FirmwareVersion':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'description':"Firmware version of the Zaber controller",
            } ],                 
        }


#------------------------------------------------------------------
#     ZaberMotorDSClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);
        print "In ZaberMotorDSClass  constructor"

#==================================================================
#
#     ZaberMotorDS class main method
#
#==================================================================
if __name__ == '__main__':
    try:
        py = PyTango.Util(sys.argv)
        py.add_TgClass(ZaberMotorDSClass, ZaberMotorDS, 'ZaberMotorDS')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed, e:
        print '-------> Received a DevFailed exception:', e
    except Exception, e:
        print '-------> An unforeseen exception occured....', e
